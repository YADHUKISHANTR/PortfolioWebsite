<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MY PROJECTS</title>
    
    <link rel="stylesheet" href="project.css">

</head>

<body>
    <nav class="navbar">
        <div class="logo">Projects</div>

        <ul class="nav-links">
            <li><a href="">Godot Projects</a></li>
            <li><a href="">Unity Projects</a></li>
            <li><a href="">AI/ML Projects</a></li>
            <li><a href="projects.html">Game Mechanics</a></li>
            <li><a href="index.html">Home</a></li>
        </ul>
    </nav>

    <h1>Game Mechanics</h1>
    <section class="mechsection spriteanim">
         <h2>Sprite Sheet Animation</h2> 
        <div class="mechanics"> 
          
    <canvas  class = "canv" id="Spriteaimation" width="500" height="300"></canvas>

    <div class="text-section">
        <p>
            <p> <b>Sprite Sheet </b> <br>A sprite sheet is one image that contains multiple animation frames arranged in rows or columns. <br>Instead of loading many separate images, the game shows different parts of the same image over time to create movement (walk, run, jump, etc.).<br>The game changes the source rectangle (the cropped area of the image) every few milliseconds to switch frames and create animation.
                <br><br><br><b>⏱️ Frame Rate (FPS) </b>
                    <br>    Game FPS → How many times the screen updates per second (e.g., 60 FPS).
                    <br>    Animation FPS → How fast the sprite changes frames (e.g., 10–15 FPS).
                    <br>    A game can run at 60 FPS, but the sprite animation can run at 12 FPS for smoother control and better performance.</p>
                      
        </p>

        <div class="fps-control">
            <label for="fpsSlider">FPS:</label>
            <input type="range" id="fpsSlider" min="1" max="24" step="1" value="10">
            <span id="fpsValue">10</span>
        </div>
        </div>

    </div>

    </section>



    <section class="mechsection bounce">
         <h2>Collision Detection</h2> 
         <div class="mechanics"> 

            <canvas class = "canv" id="BounceCanv" width="500" height="300"></canvas>

             <div class="text-section">
                <p>
                    <p>
                        In a 2D game, collision detection is the system that checks whether two objects, such as a ball and a wall, are touching or overlapping.<br><br>

                        When the game detects that the ball has collided with the wall, it triggers a collision response.<br><br>

                        One common response is bouncing, where the ball’s velocity is reversed in the direction of impact.<br><br>

                        For example, if the ball hits a vertical wall, its horizontal velocity (X direction) is inverted; if it hits the ground, its vertical velocity (Y direction) is inverted.<br><br>

                        This process of detecting a collision and then applying a bounce response creates realistic interaction and movement in the game.
                    </p>
                    
                </p>

                <div class="button">
                    <button id="BounceBtn">Restart <br> Bounce</button>
                </div>
            </div>

    </section>
    
  

    <section class="mechsection euler">
         <h2>Euler Integration</h2> 
         <div class="mechanics"> 

            <canvas class = "canv" id="EulerCanv" width="500" height="300"></canvas>

             <div class="text-section">
                <p>
                    <p>
                        <b>Euler Integration</b> <br>
                Euler Integration is a simple numerical method to simulate motion in games and physics. 
                It updates an object’s position step by step using its velocity. Acceleration can be also used to increase the velocity <br> v = v + a * Δt  <br>x = x + v * Δt <br><br>

                The basic step is: <br>
                - Update position using velocity: <br>
                &nbsp;&nbsp;&nbsp;x = x + v * Δt <br><br>
                Here: <br>
                - <b>x</b> is position, <b>v</b> is velocity, and <b>Δt</b> is the time step. <br>
                - Since velocity is constant, the object moves at the same speed in a given direction. <br><br>
                    </p>
                    
                </p>
                <div class = "buttonsection3">
                        <div><p>X velocity: </p>
                        <button id="Xminus">-</button>
                       <span id="xVelText">0</span>
                        <button id="Xplus">+</button>
                    </div>
                </div>

                <div class = "buttonsection3">
                    <div>
                        <p>Y velocity: </p>
                        <button id="Yminus">-</button>
                        <span id="yVelText">0</span>
                        <button id="Yplus">+</button>
                    </div>
                </div>
                
            </div>

    </section>

     <section class="mechsection verletropeclass">
            <div>
                    <h2>Verlet Integration</h2>

                    <p>
                    Verlet integration is a numerical method used to simulate motion in physics-based games and animations.
                    It calculates a point's new position using its current position, previous position, and acceleration.
                    Unlike Euler integration, it does not explicitly track velocity, making it more stable and energy-conserving.
                    </p>

                    <p>
                    <b>Formula:</b>
                    <br>
                    <code>newPosition = currentPosition + (currentPosition - previousPosition) + acceleration * dt²</code>
                    </p>

                    <p>
                   <b>Advantages:</b>
                    <br>
                    - More stable than Euler integration
                    <br>
                    - Conserves energy better
                    <br>
                    - Ideal for simulations with constraints, like ropes, cloth, and soft bodies
                    <br>
                    - Easy to implement for particle-based physics
                    </p> 
            </div>
         <div class="mechanics"> 

            <canvas class = "canv" id="RopeCanv" width="500" height="300"></canvas>

             <div class="text-section">
                <h3><b> Rope Simulation Using Verlet Integration </b></h3>
                    <p>
                        A rope made with Verlet integration consists of multiple points connected by distance constraints.
                        Each point stores its current and previous position.
                        </p>

                        <p>
                        Instead of using velocity, movement is calculated by:
                        <br>
                        newPosition = currentPosition + (currentPosition - previousPosition) + gravity
                        </p>

                        <p>
                        After updating positions, constraints are applied:
                        <br>
                        - Each segment tries to maintain a fixed distance between neighboring points.
                        <br>
                        - The system adjusts points repeatedly to keep the rope length consistent.
                        </p>

                        <p>
                        One end of the rope can be pinned (fixed in place),
                        while the other end swings freely due to gravity.
                        </p>

                        <p>
                        This creates smooth, natural rope movement
                        without directly calculating forces like in traditional physics engines.
                     </p>
                <div>
                   <h4>Ankhor point position</h4>
                  <label for="AnkhorSlider">Xpos:</label>
                  <input type="range" id="AnkhorSlider" min="0" max="500" step="1" value="250">
                 <span id="Xpos4">250</span>
                </div>
            </div>

    </section>

    <section class="mechsection verletclothcanv">
         <div class="mechanics"> 

            <canvas class = "canv" id="clothCanv" width="500" height="300"></canvas>

             <div class="text-section">
                <h3><b>Cloth Simulation Using Verlet Integration</b></h3>

                  <p>
                            Cloth simulation models fabric as a grid of small particles connected by
                            distance constraints. Each particle stores its current and previous position.
                            Instead of using velocity directly, Verlet integration calculates motion
                            from position differences, producing smooth and stable movement.
                        </p>

                        <p>
                            During each frame, gravity is applied to non-anchored particles, then
                            constraints are solved multiple times to maintain fixed distances between
                            neighboring points. Anchored particles remain fixed in place, allowing the
                            cloth to hang naturally while staying attached at specific points.
                        </p>

                        <ul>
                            <li>Particles store current and previous positions</li>
                            <li>Verlet integration creates stable motion without explicit velocity</li>
                            <li>Distance constraints maintain cloth structure</li>
                            <li>Multiple solver iterations improve stiffness and stability</li>
                            <li>Anchors keep selected points fixed in space</li>
                        </ul>

                <div class = "ankhorpoints">
                    <div>
                        <h4>Ankhor point 1 position</h4>
                        <label for="AnkhorSlider">Xpos:</label>
                        <input type="range" id="Ankhor1SliderX5" min="0" max="500" step="1" value="32">
                        <span id="AnkhorX5">32</span>
                    </div>
                

                    <div>
                    <h4>Ankhor point 2 position</h4>
                     <label for="AnkhorSlider">Xpos:</label>
                    <input type="range" id="Ankhor2SliderX5" min="0" max="500" step="1" value="248">
                    <span id="AnkhorX52">248</span>

                    </div>
                     <div>
                    <h4>Ankhor point 3 position</h4>
                     <label for="AnkhorSlider">Xpos:</label>
                    <input type="range" id="Ankhor3SliderX5" min="0" max="500" step="1" value="464">
                    <span id="AnkhorX53">464</span>

                    </div>
                 
                </div>
            </div>

    </section>
    
    <section class="mechsection">
         <h2>Object Instantiation</h2> 
         <div class="mechanics"> 

            <canvas class = "canv" id="ObjectCanv" width="500" height="300"></canvas>

             <div class="text-section">
                   <p>
                       Object instantiation is the process of creating a concrete instance of a class or object template in memory during program execution. 
                        When an object is instantiated, memory is allocated and its properties are initialized with defined values. 
                        Each instance maintains its own independent state and behavior while following the structure defined by its constructor or prototype.
                    </p>

                        <h3><b>Example: Shooting a Bullet</b></h3>

                        <p>
                        When the player shoots, a new bullet is created at a <strong>spawn point</strong> 
                        (the tip of the gun). The bullet’s <strong>x</strong> and <strong>y</strong> 
                        values are set to this spawn position.
                        </p>

                        <ul>
                        <li>Create a new bullet object and push it into an array.</li>
                        <li>Update its position every frame using its speed.</li>
                        <li>Draw it on the canvas.</li>
                        <li>If it moves out of bounds (beyond canvas width/height), remove it from the array.</li>
                        </ul>

                        <p>
                        Deleting off-bound bullets prevents unnecessary memory usage and keeps the game loop efficient.
                    </p>

                <div>
                  <button id="shootbtn">Shoot</button>
                </div>
            </div>

    </section>

    <section class="mechsection">
         <h2>Parallax Scrolling</h2> 

         <div class="mechanics"> 

            <canvas class = "canv" id="PrallaxCanv" width="500" height="300"></canvas>

             <div class="text-section">
                    <p>
                        Parallax scrolling is a visual technique used in 2D games and web design where multiple background layers move at different speeds to create an illusion of depth. 
                        Objects that are farther away (like mountains) move slower, while closer objects (like trees or foreground elements) move faster. 
                        This speed difference simulates perspective and makes a flat scene feel more dynamic and immersive.
                        </p>

                        <h3>Method to Implement Parallax Scrolling</h3>

                        <ul>
                        <li>Create multiple background layers (e.g.buildings, sky, mountains, trees).</li>
                        <li>Assign each layer a different movement speed (far layers = slower, near layers = faster).</li>
                        <li>Update each layer’s position inside the game loop or scroll event.</li>
                        <li>Reset the layer position when it moves off-screen to create a continuous scrolling effect.</li>
                        <li>Render layers in order from farthest to nearest to maintain depth illusion.</li>
                        </ul>

                        <p>
                        The key concept is multiplying the main camera or scroll movement by a speed factor (between 0 and 1) for distant layers. 
                        For example, if the player moves 10 pixels, a far background layer might move only 3 pixels, while a closer layer might move 8 pixels.
                    </p>

                <div>
                  
                </div>
            </div>

    </section>
    

    <section class="mechsection">
         <h2>3D Wireframe Rendering Using Manual Projection</h2> 
         <div class="mechanics"> 

            <canvas class = "canv" id="3dCanv" width="500" height="300">
               
            </canvas>

             <div class="text-section">
                <p>
                    This system implements a basic 3D wireframe engine using JavaScript and the HTML5 Canvas API, without relying on WebGL. 
                    Each shape is defined by a <strong>vertex array</strong> (3D coordinates) and an <strong>edge index array</strong> 
                    that determines how vertices are connected to form a wireframe structure.
                    </p>

                    <h3>Rendering Pipeline</h3>
                    <ol>
                    <li>
                        <strong>Rotation:</strong> Vertices are rotated using trigonometric rotation formulas 
                        (XZ & XY plane rotation in this case) to create continuous animation.
                    </li>
                    <li>
                        <strong>Translation:</strong> The object is translated along the Z-axis so it remains 
                        in front of the virtual camera.
                    </li>
                    <li>
                        <strong>Perspective Projection:</strong> A focal length formula is applied to simulate depth:
                        <pre>
                    x' = (f * x) / z
                    y' = (f * y) / z
                        </pre>
                        This makes distant points appear smaller, producing a realistic 3D effect.
                    </li>
                    <li>
                        <strong>Screen Mapping:</strong> Projected coordinates (range -1 to 1) are converted 
                        into canvas pixel coordinates.
                    </li>
                    </ol>

                    <h3>Animation Loop</h3>
                    <p>
                    At a fixed FPS, the canvas is cleared, vertices are transformed and projected, 
                    and lines are drawn between connected vertex pairs. A button dynamically switches 
                    between different predefined geometries by updating the active vertex and edge arrays.
                    </p>

                    <p>
                    Overall, this demonstrates the fundamental concepts of a 3D graphics pipeline: 
                    geometric modeling, transformation, perspective projection, and rasterization — 
                    all implemented manually.
                </p>

                <div>
                    
                  <button id = "ChangeWireframe">Change</button>
                   <button id = "showline">Show Line</button>
                    <button id = "showpoint">Show Point</button>
                </div>
            </div>

    </section>


      <section class="mechsection">
         <h2>Procedural Animation</h2> 
         <div class="mechanics"> 

            <canvas class = "" id="" width="500" height="300"></canvas>

             <div class="text-section">
                <p>
                    <p>
                        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Impedit dolorum magni possimus dicta, eius, dolores ea, tempore ratione aperiam eos voluptates cupiditate doloribus aspernatur soluta odio delectus recusandae earum perferendis.
                    </p>
                    
                </p>

                <div>
                  
                </div>
            </div>

    </section>


    <section class="mechsection">
         <h2>RagDoll</h2> 

         <div class="mechanics"> 

            <canvas class = "" id="" width="500" height="300"></canvas>

             <div class="text-section">
                <p>
                    <p>
                        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Impedit dolorum magni possimus dicta, eius, dolores ea, tempore ratione aperiam eos voluptates cupiditate doloribus aspernatur soluta odio delectus recusandae earum perferendis.
                    </p>
                    
                </p>

                <div>
                  
                </div>
            </div>

    </section>



    <section class="mechsection">
         <h2>Particle Effect</h2> 

         <div class="mechanics"> 

            <canvas class = "" id="" width="500" height="300"></canvas>

             <div class="text-section">
                <p>
                    <p>
                        Lorem, ipsum dolor sit amet consectetur adipisicing elit. Impedit dolorum magni possimus dicta, eius, dolores ea, tempore ratione aperiam eos voluptates cupiditate doloribus aspernatur soluta odio delectus recusandae earum perferendis.
                    </p>
                    
                </p>

                <div>
                  
                </div>
            </div>

    </section>


    <script src="spriteanimation.js"></script>
   
</body>
</html>